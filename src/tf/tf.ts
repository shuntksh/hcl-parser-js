// src/tf/tf.ts
import type { Block, ConfigFile, Expression } from "../types";
import { NodeTypes } from "../types";
import { TerraformSemanticError, extractAttributes } from "./common";
import { DataBlock, DataSources } from "./data";
import { OutputBlock, Outputs } from "./output";
import { ProviderBlock, Providers } from "./provider";
import { ResourceBlock, Resources } from "./resource";
import { TerraformConfigBlock } from "./terraform";
import { VariableBlock, Variables } from "./variable";

export class TF {
	public readonly variables = new Variables();
	public readonly resources = new Resources();
	public readonly dataSources = new DataSources();
	public readonly outputs = new Outputs();
	public readonly providers = new Providers();
	public readonly locals = new Map<string, Expression>();
	public terraformConfig?: TerraformConfigBlock; // Usually only one
	public readonly unknownBlocks: Block[] = []; // Store unhandled blocks

	private constructor() {
		// Private constructor to force use of static load method
	}

	/**
	 * Loads and parses the HCL AST into a structured Terraform representation.
	 * @param ast The ConfigFile AST generated by the HCL parser.
	 * @returns A TF instance populated with the Terraform configuration.
	 */
	public static load(ast: ConfigFile): TF {
		const tf = new TF();

		for (const item of ast) {
			if (item.type === NodeTypes.Attribute) {
				// Top-level attributes are not standard in Terraform
				console.warn(`Ignoring top-level attribute "${item.name.value}"`);
				continue;
			}

			// OneLineBlocks are also not standard top-level blocks
			if (item.type === NodeTypes.OneLineBlock) {
				console.warn(
					`Ignoring top-level one-line block "${item.blockType.value}"`,
				);
				continue;
			}

			// Process Blocks
			if (item.type === NodeTypes.Block) {
				try {
					switch (item.blockType.value) {
						case "variable":
							tf.variables.add(new VariableBlock(item));
							break;
						case "resource":
							tf.resources.add(new ResourceBlock(item));
							break;
						case "data":
							tf.dataSources.add(new DataBlock(item));
							break;
						case "output":
							tf.outputs.add(new OutputBlock(item));
							break;
						case "provider":
							tf.providers.add(new ProviderBlock(item));
							break;
						case "locals": {
							// Locals blocks just contain attributes
							const localAttrs = extractAttributes(item.bodies);
							for (const name in localAttrs) {
								if (tf.locals.has(name)) {
									// TF merges locals across blocks, last wins. Warn maybe?
									console.warn(
										`Local value "${name}" redefined. Last definition wins.`,
									);
								}
								tf.locals.set(name, localAttrs[name]!);
							}
							break;
						}
						case "terraform":
							if (tf.terraformConfig) {
								// Multiple terraform blocks are usually merged, but could be complex.
								// Simplest is to take the first or last, or error. Let's warn.
								console.warn(
									"Multiple 'terraform' blocks found. Only the first one is processed.",
								);
							} else {
								tf.terraformConfig = new TerraformConfigBlock(item);
							}
							break;
						// Add cases for 'module', 'moved', 'import', 'check' etc. if needed
						default:
							console.warn(
								`Unsupported top-level block type: "${item.blockType.value}". Storing as unknown.`,
							);
							tf.unknownBlocks.push(item);
					}
				} catch (error) {
					if (error instanceof TerraformSemanticError) {
						// Re-throw specific errors, or collect them
						throw error;
					}
					// Wrap unexpected errors
					throw new TerraformSemanticError(
						`Error processing block "${item.blockType.value}": ${error instanceof Error ? error.message : error}`,
						item,
					);
				}
			}
		}

		// Post-load validation could happen here
		tf.validate();

		return tf;
	}

	/**
	 * Performs basic validation checks across the loaded configuration.
	 */
	public validate(): void {
		// Example: Check if resources use defined providers
		for (const typeMap of this.resources.all.values()) {
			for (const resource of typeMap.values()) {
				if (resource.provider) {
					// This requires evaluating the provider expression, which is out of scope.
					// A simpler check might look for explicit provider strings.
					// console.log(`Resource ${resource.resourceType}.${resource.resourceName} uses provider ${marshalExpression(resource.provider)}`);
				}
				// Check depends_on? Requires expression evaluation/parsing.
			}
		}

		// Check variable usage? Requires walking all expressions. Very complex.
		console.log("Basic validation placeholder executed.");
	}
}
